<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech-to-Text with Puter.js</title>
    <script src="https://js.puter.com/v2/"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h2 i {
            font-size: 1.3rem;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            background: #4a6ee0;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background: #3a5ecf;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-record {
            background: #e74c3c;
        }

        .btn-record:hover {
            background: #c0392b;
        }

        .btn-record.recording {
            background: #c0392b;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
            }
        }

        select, input[type="file"] {
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            flex: 1;
            min-width: 200px;
        }

        select option {
            background: #2a5298;
            color: white;
        }

        .transcript-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            min-height: 200px;
            margin-top: 20px;
            overflow-y: auto;
            max-height: 400px;
        }

        .transcript-text {
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #a0c4ff;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #6c757d;
        }

        .status-dot.active {
            background: #28a745;
            animation: blink 1.5s infinite;
        }

        .status-dot.error {
            background: #e74c3c;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .file-info {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #a0c4ff;
        }

        .error-message {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 3px solid #ff6b6b;
        }

        .hidden {
            display: none;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.9rem;
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: #a0c4ff;
        }

        .info-panel ul {
            padding-left: 20px;
        }

        .info-panel li {
            margin-bottom: 5px;
        }

        .supported-formats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .format-tag {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .format-tag.highlight {
            background: rgba(74, 110, 224, 0.3);
            border: 1px solid rgba(74, 110, 224, 0.5);
        }

        .suggestion-box {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .suggestion-box h4 {
            color: #ffc107;
            margin-bottom: 8px;
        }

        .suggestion-box ul {
            padding-left: 20px;
        }

        .suggestion-box li {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            select, input[type="file"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Speech-to-Text Transcriber</h1>
            <p class="subtitle">Convert speech to text using Puter.js - No API keys required</p>
        </header>

        <div class="card">
            <h2><i>üé§</i> Live Voice Input</h2>
            <p>Record your voice and convert it to text in real-time.</p>
            
            <div class="controls">
                <button id="record-btn" class="btn-record">
                    <i>‚óè</i> Start Recording
                </button>
                
                <select id="model-select">
                    <option value="gpt-4o-mini-transcribe">GPT-4o Mini (Fast)</option>
                    <option value="gpt-4o-transcribe">GPT-4o (High Quality)</option>
                </select>
                
                <label>
                    <input type="checkbox" id="translate-checkbox"> Translate to English
                </label>
            </div>
            
            <div class="status">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text">Ready to record</span>
            </div>
            
            <div class="transcript-container">
                <div id="transcript" class="transcript-text">Your transcript will appear here...</div>
                <div id="transcript-error" class="error-message hidden"></div>
            </div>
            
            <div class="actions">
                <button id="copy-btn" class="btn-secondary">Copy Text</button>
                <button id="clear-btn" class="btn-secondary">Clear</button>
            </div>
        </div>

        <div class="card">
            <h2><i>üìÅ</i> Upload Audio File</h2>
            
            <div class="controls">
                <input type="file" id="audio-upload" accept="audio/*,.mp3,.m4a,.wav,.ogg,.webm">
                <button id="upload-transcribe-btn">Transcribe File</button>
            </div>
            
            <div class="supported-formats">
                <span class="format-tag highlight">MP3</span>
                <span class="format-tag">WAV</span>
                <span class="format-tag">M4A</span>
                <span class="format-tag">OGG</span>
                <span class="format-tag">WebM</span>
            </div>
            
            <div class="file-info" id="file-info"></div>
            
            <div class="transcript-container">
                <div id="file-transcript" class="transcript-text">File transcript will appear here...</div>
                <div id="file-error" class="error-message hidden"></div>
                <div id="file-suggestions" class="suggestion-box hidden">
                    <h4>Having issues with your MP3 file?</h4>
                    <ul>
                        <li>Try converting your MP3 to WAV format using an online converter</li>
                        <li>Ensure your MP3 file uses standard encoding (not variable bitrate)</li>
                        <li>Try a shorter audio file (under 5 minutes)</li>
                        <li>Check if the file plays normally in a media player</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <h3>Tips for Best Results:</h3>
            <ul>
                <li>Use a quiet environment for recording</li>
                <li>Speak clearly and at a moderate pace</li>
                <li>Ensure good microphone quality</li>
                <li>For file uploads, WAV files typically work best</li>
                <li>Keep files under 25MB for optimal performance</li>
                <li>If MP3 files fail, try converting to WAV format</li>
            </ul>
        </div>

        <footer>
            <p>Powered by Puter.js | No API keys required | User pays for their own usage</p>
        </footer>
    </div>

    <script>
        // DOM Elements
        const recordBtn = document.getElementById('record-btn');
        const modelSelect = document.getElementById('model-select');
        const translateCheckbox = document.getElementById('translate-checkbox');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const transcript = document.getElementById('transcript');
        const transcriptError = document.getElementById('transcript-error');
        const copyBtn = document.getElementById('copy-btn');
        const clearBtn = document.getElementById('clear-btn');
        const audioUpload = document.getElementById('audio-upload');
        const uploadTranscribeBtn = document.getElementById('upload-transcribe-btn');
        const fileInfo = document.getElementById('file-info');
        const fileTranscript = document.getElementById('file-transcript');
        const fileError = document.getElementById('file-error');
        const fileSuggestions = document.getElementById('file-suggestions');

        // Variables
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;

        // Check if browser supports media recording
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showError(transcriptError, "Your browser doesn't support audio recording. Please use a modern browser like Chrome, Firefox, or Edge.");
            recordBtn.disabled = true;
        }

        // Event Listeners
        recordBtn.addEventListener('click', toggleRecording);
        copyBtn.addEventListener('click', copyTranscript);
        clearBtn.addEventListener('click', clearTranscript);
        uploadTranscribeBtn.addEventListener('click', transcribeUploadedFile);

        // Utility function to extract meaningful error messages
        function extractErrorMessage(error) {
            // If it's already a string, return it
            if (typeof error === 'string') return error;
            
            // If it has a message property
            if (error.message) return error.message;
            
            // If it's an object with a toString method
            if (error.toString && error.toString() !== '[object Object]') {
                return error.toString();
            }
            
            // Try to stringify and parse for nested errors
            try {
                const stringified = JSON.stringify(error);
                if (stringified !== '{}') return stringified;
            } catch (e) {
                // If stringify fails, continue to next method
            }
            
            // Check for common error patterns in Puter.js
            if (error.error) {
                return extractErrorMessage(error.error);
            }
            
            if (error.details) {
                return extractErrorMessage(error.details);
            }
            
            // Default fallback
            return "An unknown error occurred. Please try again.";
        }

        // Show error message in the UI
        function showError(errorElement, message) {
            errorElement.textContent = message;
            errorElement.classList.remove('hidden');
            statusDot.classList.add('error');
        }

        // Hide error message
        function hideError(errorElement) {
            errorElement.classList.add('hidden');
            statusDot.classList.remove('error');
        }

        // Toggle recording function
        async function toggleRecording() {
            if (!isRecording) {
                // Start recording
                try {
                    hideError(transcriptError);
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        } 
                    });
                    
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = async () => {
                        try {
                            if (audioChunks.length === 0) {
                                throw new Error("No audio data recorded. Please try again.");
                            }
                            
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            await transcribeAudio(audioBlob);
                        } catch (error) {
                            console.error('Error processing recording:', error);
                            showError(transcriptError, extractErrorMessage(error));
                            statusText.textContent = 'Recording failed';
                        } finally {
                            stream.getTracks().forEach(track => track.stop());
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event);
                        showError(transcriptError, "Recording error occurred. Please try again.");
                        statusText.textContent = 'Recording error';
                        isRecording = false;
                        recordBtn.innerHTML = '<i>‚óè</i> Start Recording';
                        recordBtn.classList.remove('recording');
                        statusDot.classList.remove('active');
                    };
                    
                    mediaRecorder.start(1000); // Collect data every second
                    isRecording = true;
                    recordBtn.innerHTML = '<i>‚ñ†</i> Stop Recording';
                    recordBtn.classList.add('recording');
                    statusDot.classList.add('active');
                    statusText.textContent = 'Recording...';
                    transcript.textContent = 'Recording in progress...';
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    let errorMessage = "Error accessing microphone. ";
                    
                    if (error.name === 'NotAllowedError') {
                        errorMessage += "Please allow microphone access and try again.";
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += "No microphone found. Please check your audio devices.";
                    } else {
                        errorMessage += extractErrorMessage(error);
                    }
                    
                    showError(transcriptError, errorMessage);
                    recordBtn.disabled = true;
                }
            } else {
                // Stop recording
                try {
                    mediaRecorder.stop();
                    isRecording = false;
                    recordBtn.innerHTML = '<i>‚óè</i> Start Recording';
                    recordBtn.classList.remove('recording');
                    statusDot.classList.remove('active');
                    statusText.textContent = 'Processing...';
                    transcript.textContent = 'Processing audio...';
                } catch (error) {
                    console.error('Error stopping recording:', error);
                    showError(transcriptError, extractErrorMessage(error));
                    statusText.textContent = 'Error stopping recording';
                }
            }
        }

        // Transcribe audio using Puter.js
        async function transcribeAudio(audioBlob) {
            try {
                const model = modelSelect.value;
                const translate = translateCheckbox.checked;
                
                // Validate audio blob
                if (!audioBlob || audioBlob.size === 0) {
                    throw new Error("No audio data to transcribe. Please try recording again.");
                }
                
                // Check file size (limit to 10MB for recordings)
                const maxSize = 10 * 1024 * 1024; // 10MB in bytes
                if (audioBlob.size > maxSize) {
                    throw new Error("Recording is too long. Please try a shorter recording.");
                }
                
                const options = {
                    file: audioBlob,
                    model: model
                };
                
                if (translate) {
                    options.translate = true;
                }
                
                // Add timeout for transcription
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("Transcription timeout. Please try again.")), 60000); // 60 seconds
                });
                
                const transcriptionPromise = puter.ai.speech2txt(options);
                
                const result = await Promise.race([transcriptionPromise, timeoutPromise]);
                
                // Handle different response formats
                let transcriptText = '';
                if (typeof result === 'string') {
                    transcriptText = result;
                } else if (result.text) {
                    transcriptText = result.text;
                } else if (result.segments && Array.isArray(result.segments)) {
                    // Handle diarized format
                    transcriptText = result.segments.map(segment => {
                        const speaker = segment.speaker || 'Speaker';
                        return `${speaker}: ${segment.text}`;
                    }).join('\n\n');
                } else {
                    // Fallback - try to stringify the result
                    transcriptText = JSON.stringify(result, null, 2);
                }
                
                if (!transcriptText || transcriptText.trim() === '') {
                    throw new Error("Transcription returned empty result. Please try again.");
                }
                
                transcript.textContent = transcriptText;
                statusText.textContent = 'Transcription complete';
                hideError(transcriptError);
            } catch (error) {
                console.error('Transcription error:', error);
                let errorMessage = "Error during transcription: " + extractErrorMessage(error);
                
                // Provide user-friendly messages for common errors
                if (errorMessage.includes("network") || errorMessage.includes("fetch")) {
                    errorMessage = "Network error. Please check your internet connection and try again.";
                } else if (errorMessage.includes("timeout")) {
                    errorMessage = "Transcription took too long. Please try again with a shorter recording.";
                }
                
                showError(transcriptError, errorMessage);
                statusText.textContent = 'Transcription failed';
                transcript.textContent = 'Transcription failed. Please try again.';
            }
        }

        // Transcribe uploaded file
        async function transcribeUploadedFile() {
            const file = audioUpload.files[0];
            
            if (!file) {
                showError(fileError, "Please select an audio file first.");
                return;
            }
            
            // Enhanced file type validation with better MP3 support
            const allowedTypes = [
                'audio/mpeg',           // MP3
                'audio/mp3',            // MP3 (alternative)
                'audio/wav',            // WAV
                'audio/mp4',            // M4A/MP4
                'audio/webm',           // WebM
                'audio/ogg',            // OGG
                'audio/x-m4a',          // M4A
                'audio/x-wav'           // WAV
            ];
            
            const allowedExtensions = /\.(mp3|wav|m4a|webm|ogg)$/i;
            
            // Check both MIME type and file extension for better MP3 support
            const isTypeValid = allowedTypes.includes(file.type);
            const isExtensionValid = allowedExtensions.test(file.name);
            
            if (!isTypeValid && !isExtensionValid) {
                showError(fileError, "Unsupported file type. Please use MP3, WAV, M4A, WebM, or OGG files.");
                return;
            }
            
            // Check file size (limit to 25MB to avoid issues)
            const maxSize = 25 * 1024 * 1024; // 25MB in bytes
            if (file.size > maxSize) {
                showError(fileError, "File is too large. Please select a file smaller than 25MB.");
                return;
            }
            
            if (file.size === 0) {
                showError(fileError, "File is empty. Please select a valid audio file.");
                return;
            }
            
            fileInfo.textContent = `Processing: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            fileTranscript.textContent = 'Transcribing...';
            hideError(fileError);
            fileSuggestions.classList.add('hidden');
            
            try {
                const model = modelSelect.value;
                const translate = translateCheckbox.checked;
                
                const options = {
                    file: file,
                    model: model
                };
                
                if (translate) {
                    options.translate = true;
                }
                
                // Add timeout for transcription
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error("Transcription timeout. Please try again.")), 120000); // 120 seconds for files
                });
                
                const transcriptionPromise = puter.ai.speech2txt(options);
                
                const result = await Promise.race([transcriptionPromise, timeoutPromise]);
                
                // Handle different response formats
                let transcriptText = '';
                if (typeof result === 'string') {
                    transcriptText = result;
                } else if (result.text) {
                    transcriptText = result.text;
                } else if (result.segments && Array.isArray(result.segments)) {
                    // Handle diarized format
                    transcriptText = result.segments.map(segment => {
                        const speaker = segment.speaker || 'Speaker';
                        return `${speaker}: ${segment.text}`;
                    }).join('\n\n');
                } else {
                    // Fallback - try to stringify the result
                    transcriptText = JSON.stringify(result, null, 2);
                }
                
                if (!transcriptText || transcriptText.trim() === '') {
                    throw new Error("Transcription returned empty result. The audio might be too quiet, in an unsupported language, or the file format may have issues.");
                }
                
                fileTranscript.textContent = transcriptText;
                fileInfo.textContent = `Transcription complete: ${file.name}`;
                hideError(fileError);
                fileSuggestions.classList.add('hidden');
            } catch (error) {
                console.error('Transcription error:', error);
                let errorMessage = "Error during transcription: " + extractErrorMessage(error);
                
                // Provide user-friendly messages for common errors
                if (errorMessage.includes("network") || errorMessage.includes("fetch")) {
                    errorMessage = "Network error. Please check your internet connection and try again.";
                } else if (errorMessage.includes("timeout")) {
                    errorMessage = "Transcription took too long. Please try again with a smaller file.";
                } else if (errorMessage.includes("format") || errorMessage.includes("codec") || 
                           errorMessage.includes("corrupted") || errorMessage.includes("400")) {
                    errorMessage = "Audio file format issue. The file might be corrupted or use an unsupported codec.";
                    // Show suggestions for MP3 issues
                    if (file.name.toLowerCase().endsWith('.mp3')) {
                        fileSuggestions.classList.remove('hidden');
                    }
                } else if (errorMessage.includes("MP3") || errorMessage.includes("mp3")) {
                    errorMessage = "MP3 file format issue. Please ensure your MP3 file uses standard encoding.";
                    fileSuggestions.classList.remove('hidden');
                }
                
                showError(fileError, errorMessage);
                fileInfo.textContent = 'Transcription failed';
                fileTranscript.textContent = 'Transcription failed. Please try again.';
            }
        }

        // Copy transcript to clipboard
        async function copyTranscript() {
            const textToCopy = transcript.textContent;
            
            if (textToCopy && textToCopy !== 'Your transcript will appear here...' && 
                !textToCopy.includes('Recording in progress...') && 
                !textToCopy.includes('Processing audio...') &&
                !textToCopy.includes('Transcription failed')) {
                
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    // Show temporary feedback
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    showError(transcriptError, "Failed to copy text to clipboard. You can manually select and copy the text.");
                }
            } else {
                showError(transcriptError, "No transcript available to copy.");
            }
        }

        // Clear transcript
        function clearTranscript() {
            transcript.textContent = 'Your transcript will appear here...';
            hideError(transcriptError);
            statusText.textContent = 'Ready to record';
            statusDot.classList.remove('active', 'error');
        }
    </script>
</body>
</html>
